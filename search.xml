<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>博客平台搭建</title>
      <link href="/2019/09/03/platform-building/"/>
      <url>/2019/09/03/platform-building/</url>
      
        <content type="html"><![CDATA[<h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>最近博客平台的搭建也告一段落了，再次感谢各位开源大佬，没有你们的支持，我这个小破站也搭建不起来(╯▔皿▔)╯。废话不多说，整个小博客网站主要是借助<a href="https://hexo.io/" target="_blank" rel="noopener">hexo</a>博客框架和<a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank" rel="noopener">3-hexo</a>这个博客主题完成的，3-hexo主题的使用demo可以查看本站下方的友链部分。整个搭建过程真的踩了不少坑，下面我也会分模块尽可能一一讲述清楚。</p><h2 id="hexo搭建步骤"><a href="#hexo搭建步骤" class="headerlink" title="hexo搭建步骤"></a>hexo搭建步骤</h2><h3 id="必要条件"><a href="#必要条件" class="headerlink" title="必要条件"></a>必要条件</h3><ol><li>戳<a href="https://nodejs.org/en/" target="_blank" rel="noopener">nodejs</a>，下载nodejs并安装（本人是在windows上面搭建的），nodejs主要使用npm命令来安装hexo框架的各种插件；</li><li>戳<a href="https://gitforwindows.org/" target="_blank" rel="noopener">git</a>安装windows版git，主要目的是让hexo和github pages配合更新。</li></ol><h3 id="hexo安装"><a href="#hexo安装" class="headerlink" title="hexo安装"></a>hexo安装</h3><p>使用git-bash或者cmd即可安装hexo</p><pre><code>$ npm install -g hexo-cli</code></pre><h3 id="网站配置"><a href="#网站配置" class="headerlink" title="网站配置"></a>网站配置</h3><p>在你指定的存放网站文件的目录下（我的是brightblog，这个目录在后文将被称为hexo根目录）执行下面三行命令：</p><pre><code>$ hexo init brightblog$ cd brightblog$ npm install</code></pre><p>新建完成后可以看到目录下的结构为：</p><pre><code>.├── _config.yml├── package.json├── scaffolds├── source|   ├── _drafts|   └── _posts└── themes</code></pre><p>各个目录的主要功能如下所示：</p><table><thead><tr><th>文件/目录</th><th>功能</th></tr></thead><tbody><tr><td>_config.xml</td><td>网站的<a href="https://hexo.io/zh-cn/docs/configuration.html" target="_blank" rel="noopener">配置</a>文件</td></tr><tr><td>package.json</td><td>应用程序的信息</td></tr><tr><td>scaffolds</td><td><a href="https://hexo.io/zh-cn/docs/templates.html" target="_blank" rel="noopener">模版</a>文件夹。当您新建文章时，Hexo 会根据scaffold来建立文件</td></tr><tr><td>source</td><td><a href="https://hexo.io/zh-cn/docs/asset-folders.html" target="_blank" rel="noopener">资源文件夹</a>是存放用户资源的地方。除 posts 文件夹之外，开头命名为 (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去</td></tr><tr><td>themes</td><td><a href="https://hexo.io/zh-cn/docs/themes.html" target="_blank" rel="noopener">主题</a>文件夹，Hexo 会根据主题来生成静态页面</td></tr></tbody></table><br>个人认为比较重要的几个文件_config.yml，source目录和themes目录，它们分别是你配置网站，存在博客和存放主题的地方。关于_config.yml，我配置的几个主要地方是：<pre><code># 网站标题title: Zeroone# 作者名字author: J. Zhang# 站点的urlurl: https://blog.jtzhang.xyz# 使用的主题，所有的主题都按照名称存放在themes目录下，可根据需要切换theme: hexo-theme-3-hexo# 开启全文搜索(in:)search:  path: search.xml  field: post# 站点部署配置deploy:  - type: git    repo: git@github.com:brightLLer/brightLLer.github.io.git    branch: master</code></pre><h3 id="下载和配置主题"><a href="#下载和配置主题" class="headerlink" title="下载和配置主题"></a>下载和配置主题</h3><p>切换到hexo根目录下的themes文件夹，并执行如下命令下载主题（我使用的是3-hexo主题）：</p><pre><code>$ cd themes/$ git init$ git clone https://github.com/yelog/hexo-theme-3-hexo.git</code></pre><p>下载好的主题的名字要配置在hexo根目录下的_config.yml文件中（见上一小节）。一般来说，一个主题的目录具有如下的文件结构：</p><pre><code>.├── _config.yml├── languages├── layout├── scripts└── source</code></pre><p>主题目录下各个文件/目录的主要功能如下所示:</p><table><thead><tr><th>文件/目录</th><th>功能</th></tr></thead><tbody><tr><td>_config.yml</td><td>主题的配置文件</td></tr><tr><td>languages</td><td>语言文件夹，请参见<a href="https://hexo.io/zh-cn/docs/internationalization.html" target="_blank" rel="noopener">国际化 (i18n)</a></td></tr><tr><td>layout</td><td>布局文件夹。用于存放主题的<a href="https://hexo.io/zh-cn/docs/templates.html" target="_blank" rel="noopener">模板</a>文件，决定了网站内容的呈现方式，您可参考模板以获得更多信息</td></tr><tr><td>scripts</td><td>脚本文件夹。在启动时，Hexo 会载入此文件夹内的 JavaScript 文件，参见<a href="https://hexo.io/zh-cn/docs/plugins.html" target="_blank" rel="noopener">插件</a>获取更多信息</td></tr><tr><td>source</td><td>资源文件夹，除了模板以外的 Asset，例如 CSS、JavaScript 文件等，都应该放在这个文件夹中。文件或文件夹开头名称为 _（下划线线）或隐藏的文件会被忽略</td></tr></tbody></table><br>这里值得一提的是_config.yml文件，这个文件与hexo根目录下的_config.yml文件是不一样的，前者主要用于主题相关的配置，后者则主要是进行网站本身的全局配置。关于主题目录下的_config.yml，我配置的几个主要地方是：<pre><code># 你的头像urlavatar: /img/zeroone.pngfavicon: /img/zeroone.png#链接图标 显示顺序和下面顺序一致link:  theme: color # 链接样式，color: 彩色图标  white: 黑白图标  items:    # rss: /atom.xml    github: https://github.com/brightLLer    zhihu: https://www.zhihu.com/people/brightspring/activities    email: 1277472231@qq.com    qq: 1277472231menu:  about:  # &#39;关于&#39; 按钮    on: true # 是否显示    url: /about  # 跳转链接    type: 1 # 跳转类型 1：站内异步跳转 2：当前页面跳转 3：打开新的tab页  friend: # &#39;友链&#39; 按钮    on: true # 是否展示  menus:    github:      on: true      url: https://github.com/brightller      type: 3  # 跳转类型 3：打开新的tab页article_txt: 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论，也可以邮件至 1277472231@qq.combottom_text: ©2019 Jiantao Zhangreward: true# true 开启打赏功能searchAll: true# true 启用全文搜索# 开启此功能需要下面操作：# 1. 在 hexo 根目录 执行 npm install hexo-generator-search --save 安装插件# 2. 在 hexo 根目录的 _config.xml 中添加下面内容# search:#   path: search.xml#   field: postword_count: true# true 开启字数统计# 开启此功能需要安装插件 ：在 hexo根目录 执行npm i hexo-wordcount --savecomment:  on: true  type: gitalk  # 评论系统：gitalk、disqus、gentie、gitment,注意：使用时，在下方对应位置进行配置  comment_count: true  # 文章标题下方显示评论数  preload_comment: false  # 预加载评论区  ## false: 当点击评论条等区域时再加载评论模块  ## true: 页面加载时加载评论区gitalk:  githubID: brightller  repo: brightller.github.io  ClientID:  ClientSecret:  adminUser: brightller  distractionFreeMode: true  language: zh-CN  perPage: 10# gitalk：利用github issue制作的第三方聊天插件# https://github.com/gitalk/gitalk# 参数介绍：# githubID: github用户名# repo: 使用哪个仓库的issue# ClientID 和 ClientSecret 创建 OAuth application 就会生成：https://github.com/settings/applications/new# adminUser: 必须为上面仓库的合作者（有写入权限），使用自己的 github 用户名即可# distractionFreeMode: 全屏遮罩效果# language: 语言：支持：en / zh-CN / zh-TW 三种# perPage: 每次加载的数据大小，默认10，最大100</code></pre><h2 id="站点测试和部署"><a href="#站点测试和部署" class="headerlink" title="站点测试和部署"></a>站点测试和部署</h2><p>在hexo根目录/站点根目录(brightblog)下打开cmd命令行，执行如下命令</p><pre><code>hexo s</code></pre><p>之后再浏览器的地址栏输入<code>http://localhost:4000</code>就可以看到测试的站点，如下图所示，按住<code>Ctrl+C</code>可以退出本地测试。<br><img src="/img/local-test.png"><br>如果检查后觉得测试页面没有什么问题，就可以部署到Github pages上面了。</p><ol><li><p>首先在git-bash上执行如下命令安装部署hexo站点用的插件：</p><pre><code>npm install hexo-deployer-git --save</code></pre></li><li><p>在Github上创建名为<code>&lt;username&gt;.github.io</code>的仓库，比如我的就是<code>brightller.github.io</code></p></li><li><p>在网站的配置文件（不是主题的配置文件）_config.yml中填好部署的配置：</p><pre><code>deploy:- type: git repo: git@github.com:brightLLer/brightLLer.github.io.git branch: master</code></pre></li><li><p>一般来说,github提交代码有两种方式，一种为HTTPS方式，另一种为SSH方式：</p><pre><code># HTTPS方式:https://github.com/brightLLer/brightLLer.github.io.git# SSH方式:git@git.com:brightLLer/brightLLer.github.io.git</code></pre><p>以HTTPS方式提交代码需要每次手动输入github的账号密码，而SSH方式是将本地系统的公钥(每换一台电脑就要重新生成一次)提供给github，之后就不需要每次手动输入账号和密码了，回头看第3点，由于部署的方式是SSH方式，因此我们需要先生成SSH密钥：</p><pre><code>ssh-keygen -t rsa -C &quot;1277472231@qq.com&quot;</code></pre><p>接着切换到<code>C:\Users\&lt;local_user&gt;\.ssh</code>下，可以看到目录结构：</p><pre><code>.├── id_rsa├── id_rsa.pub└── known_hosts</code></pre><p>将id_rsa.pub中的公钥复制到github上面：</p><pre><code>头像 -&gt; settings -&gt; SSH and GPG keys -&gt; New SSH key -&gt; 填写title(随意)和key</code></pre><img src="/img/SSH-github.png"></li><li><p>关联本地仓库和远程仓库:</p><pre><code>git remote add origin git@git.com:brightLLer/brightLLer.github.io.git# 或者git remote add origin https://github.com/brightLLer/brightLLer.github.io.git# 可缺省https链接</code></pre></li><li><p>最终部署：</p><pre><code># 第一次部署hexo deploy# 非第一次部署（修改过内容后重新部署，如主题）hexo cleanhexo generatehexo deploy</code></pre></li></ol><p>除此之外，为了开启评论系统Gitalk，我们需要注册<a href="https://github.com/settings/applications/new" target="_blank" rel="noopener">OAuth Application</a>，进去之后我们可以看到下方的界面：<br><img src="/img/OAuth-App.png"><br>这里<code>https://blog.jtzhang.xyz/</code>是我申请的域名，如果没有域名就还是填原来的<code>https://&lt;username&gt;.github.io/</code>就可以了，注册好之后我们会得到自己的<code>client_id</code>和<code>client_secret</code>，可以在github中采用如下方式进入查看：</p><pre><code>头像 -&gt; Developer settings -&gt; OAuth Apps -&gt; App头像</code></pre><p>将它们填写到主题配置文件_config.yml（注意不是网站配置文件_config.yml）上对应的位置就可以了：</p><pre><code>gitalk:  githubID: brightller  repo: brightller.github.io  ClientID: your client_id  ClientSecret: your client_secret  adminUser: brightller  distractionFreeMode: true  language: zh-CN  perPage: 10</code></pre><h2 id="申请自己的域名"><a href="#申请自己的域名" class="headerlink" title="申请自己的域名"></a>申请自己的域名</h2><p>由于我使用的是腾讯云，所以将腾讯云作为例子，其它平台的操作也是类似的。</p><ol><li>注册腾讯云账号，登录，进入控制台，购买域名，域名大部分需要实名认证，上传自己的身份证即可，审核一般当天能完成.</li><li>进入域名管理，如果审核通过了，可以看到：<img src="/img/domain-manage.png"></li><li>点击上图中的解析，进入之后点击添加如下3条记录，其中前两条是固定的，解析的是github的IP地址，最后一条请填写你自己的仓库名<code>&lt;username&gt;.github.io</code>，主机记录可以随意填，既然是博客可以采用blog这样的一个二级域名，记录类型建议填写CNAME，不要填A，这样github仓库待24小时内审核之后可以直接勾上enfore https，这样网站就可以安全访问了：<img src="/img/all-records.png"><img src="/img/enforce-https.png"></li><li>域名注册成功后就可以直接使用域名访问自己的网站了.</li></ol>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 3-hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>librosa术语介绍</title>
      <link href="/2019/09/02/librosa-term/"/>
      <url>/2019/09/02/librosa-term/</url>
      
        <content type="html"><![CDATA[<h1 id="librosa中的相关术语介绍"><a href="#librosa中的相关术语介绍" class="headerlink" title="librosa中的相关术语介绍"></a>librosa中的相关术语介绍</h1><blockquote><p>注：librosa是一个音频处理库，戳<a href="http://librosa.github.io/librosa/" target="_blank" rel="noopener">这里</a>看官方document。</p></blockquote><h2 id="术语解释"><a href="#术语解释" class="headerlink" title="术语解释"></a>术语解释</h2><h3 id="time-series"><a href="#time-series" class="headerlink" title="time series"></a><strong>time series</strong></h3><p>Typically an audio signal, denoted by <code>y</code>, and represented as a one-dimensional numpy.ndarray of floating-point values. <code>y[t]</code> corresponds to amplitude of the waveform at sample <code>t</code>.<br>时间序列：一般指的是音频信号，用<code>y</code>来表示，<code>y</code>是一个浮点类型的一维数组，<code>y[t]</code>表示波形图中样本<code>t</code>处的幅度值</p><h3 id="sampling-rate"><a href="#sampling-rate" class="headerlink" title="sampling rate"></a><strong>sampling rate</strong></h3><p>The (positive integer) number of samples per second of a time series. This is denoted by an integer variable <code>sr</code>.<br>采样频率：时间序列中，每秒的样本数目（一个正整数）。经常用一个整型变量<code>sr</code>来表示</p><h3 id="frame"><a href="#frame" class="headerlink" title="frame"></a><strong>frame</strong></h3><p>A short slice of a time series used for analysis purposes. This usually corresponds to a single column of a spectrogram matrix.<br>帧：一个时间序列的短切片，常用于分析。帧通常与时频矩阵中一个单独的列相关（specgram的行表示频率，列表示时间），强调一点，帧的意义是时间上的。</p><h3 id="window"><a href="#window" class="headerlink" title="window"></a><strong>window</strong></h3><p>The (positive integer) number of samples in an analysis window (or frame). This is denoted by an integer variable <code>n_fft</code>.<br>在一个分析窗（或者帧）内的样本的数目（一个正整数）。用整型变量<code>n_fft</code>来表示。<br>注：1、傅里叶变换只能对作用于有限长度的信号，因此才要对信号采样，采样数目<code>n_fft</code>就是一帧的长度<br>2、帧的中心样本称为center，<code>stft</code>等函数中，<code>center</code>参数若为<code>True</code>，信号y会被左右填充(padded)以确保第<code>k</code>帧以<code>k*hop_length</code>那个样本为中心（v3.0开始），若为<code>False</code>，则不填充而且第k帧的起点就是<code>k*hop_length</code>那个样本。对应到specgram中就是<code>D[:, t]</code>或者<code>S[:, t]</code><br>center : boolean</p><ul><li>If <code>True</code>, the signal <code>y</code> is padded so that frame <code>D[:, t]</code> is centered at <code>y[t * hop_length]</code>.</li><li>If <code>False</code>, then <code>D[:, t]</code> begins at <code>y[t * hop_length]</code><h3 id="hop-length"><a href="#hop-length" class="headerlink" title="hop length"></a><strong>hop length</strong></h3>The number of samples between successive frames, e.g., the columns of a spectrogram. This is denoted as a positive integer <code>hop_length</code>.<br>帧移：连续帧之间的样本数目，用一个正整数变量<code>hop_length</code>来表示。注：其实就是上一帧的起点到下一帧起点的位移<h3 id="window-length"><a href="#window-length" class="headerlink" title="window length"></a><strong>window length</strong></h3>The length (width) of the window function (e.g., Hann window). Note that this can be smaller than the frame length used in a short-time Fourier transform. Typically denoted as a positive integer variable <code>win_length</code>.<br>窗长度：窗的长度（宽度），在短时傅里叶变换中可以比帧长度小（多数时候两者长度一样，窗长小于帧长时使用零填充补充至长度相等）。经常用正整数变量<code>win_length</code>来表示<h3 id="spectrogram"><a href="#spectrogram" class="headerlink" title="spectrogram"></a><strong>spectrogram</strong></h3>A matrix <code>S</code> where the rows index frequency bins, and the columns index frames (time). Spectrograms can be either real-valued or complex-valued. By convention, real-valued spectrograms are denoted as numpy.ndarrays <code>S</code>, while complex-valued STFT matrices are denoted as <code>D</code>.<br>时频矩阵：一个矩阵，其行索引频带，列索引帧（时间）。时频矩阵的元素可以是实数也可以是复数。按照约定俗成的表示，实数时频矩阵用数组<code>S</code>表示，而复数STFT矩阵则用<code>D</code>表示<br><code>np.abs(D[f, t])</code> is the magnitude of frequency bin <code>f</code> at frame <code>t</code><br><code>np.angle(D[f, t])</code> is the phase of frequency bin <code>f</code> at frame <code>t</code><h3 id="onset-strength-envelope"><a href="#onset-strength-envelope" class="headerlink" title="onset (strength) envelope"></a><strong>onset (strength) envelope</strong></h3>An onset envelope <code>onset_env[t]</code> measures the strength of note onsets at frame <code>t</code>. Typically stored as a one-dimensional numpy.ndarray of floating-point values onset_envelope.<br>帧起点数组：记录着每一帧起始时刻处的强度，用一个浮点型一维数组<code>onset_envelope</code>来表示</li></ul>]]></content>
      
      
      <categories>
          
          <category> 语音分离 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> librosa </tag>
            
            <tag> signal processing </tag>
            
            <tag> speech separation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>librosa补充(一)</title>
      <link href="/2019/09/02/librosa-additional/"/>
      <url>/2019/09/02/librosa-additional/</url>
      
        <content type="html"><![CDATA[<h1 id="补充几个概念以及对部分API的理解"><a href="#补充几个概念以及对部分API的理解" class="headerlink" title="补充几个概念以及对部分API的理解"></a>补充几个概念以及对部分API的理解</h1><blockquote><p>注：时域信号在经过傅里叶变换转换之后一般为复数形式</p></blockquote><h2 id="amplitude和magnitude的区别"><a href="#amplitude和magnitude的区别" class="headerlink" title="amplitude和magnitude的区别"></a><strong>amplitude和magnitude的区别</strong></h2><ul><li>peak amplitude, often shortened to amplitude, is the nonnegative value of the waveform’s peak (either positive or negative).(强调信号的峰值)</li><li>instantaneous amplitude of x is the value of x(t) (either positive or negative) at time t.（瞬时幅度，信号x(t)在t处的值）</li><li>instantaneous magnitude, or simply magnitude, of x is nonnegative and is given by |x(t)|.（瞬时幅度，信号x(t)的模）<br>需要特意强调的就是，magnitude指的是模，不过在多数情况下，amplitude和magnitude在fft中一般是同一个意思。</li></ul><h2 id="振幅，分贝-dB-和能量-power-之间的转换关系"><a href="#振幅，分贝-dB-和能量-power-之间的转换关系" class="headerlink" title="振幅，分贝(dB)和能量(power)之间的转换关系"></a><strong>振幅，分贝(dB)和能量(power)之间的转换关系</strong></h2><ul><li><p>振幅：由于傅里叶变换之后得到的为复数T-F矩阵D，在python里，可以简单得到振幅的T-F矩阵和相位(幅角)的T-F矩阵：</p><pre><code>S = np.abs(D)P = np.angle(D)</code></pre></li><li><p>分贝：librosa的官方文档中对分贝的计算公式定义如下：</p><pre><code>S_db = 20 * np.log10(S / ref)</code></pre><p>其中ref的默认取值为1.0，不过文档似乎更习惯于用<code>ref = np.max(S)</code></p></li><li><p>能量：T-F矩阵中每个T-F单元的能量就是幅值取平方即可</p><pre><code>S_power = S ** 2</code></pre><h2 id="librosa中xx-to-xx型的API"><a href="#librosa中xx-to-xx型的API" class="headerlink" title="librosa中xx_to_xx型的API"></a><strong>librosa中xx_to_xx型的API</strong></h2></li><li><p><code>amplitude_to_db(S[, ref, amin, top_db])</code><br>该API是将幅值转换为分贝，这里的第一个参数S，按照librosa相关术语的描述，应该是一个实数T-F矩阵而不是复数T-F矩阵，但实际测试的时候发现API传入S和D的效果是一样的，源码内部实际上有一句<code>magnitude = np.abs(S)</code>，那么说明参数中的S实际上是被当成D来看的，D中的每个瞬时值被称为amplitude，不过从字面意义上来看，还是当成实数T-F矩阵S来看比较好，也就是说时域信号<code>y</code>经过STFT变换后得到<code>D</code>，先经过<code>S = np.abs(D)</code>之后再传入该API中的S，当然直接传入<code>D</code>也没有任何问题。此外该<code>amplitude_to_db(S)</code>与<code>power_to_db(S ** 2)</code>等价。</p></li><li><p><code>db_to_amplitude(S_db[, ref])</code><br>将分贝转换为幅值。这里的幅值是实数，用magnitude更合适，强调模S。</p></li><li><p><code>power_to_db(S[, ref, amin, top_db, ref_power])</code><br>能量转换为分贝，ref_power参数会在0.6.0版本起抛弃。</p></li><li><p><code>db_to_power(S_db[, ref])</code><br>分贝转换为能量。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 语音分离 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> librosa </tag>
            
            <tag> signal processing </tag>
            
            <tag> speech separation </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
