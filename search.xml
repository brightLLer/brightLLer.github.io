<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>leetcode笔记(二)</title>
      <link href="/2019/09/10/leetcode-note-2/"/>
      <url>/2019/09/10/leetcode-note-2/</url>
      
        <content type="html"><![CDATA[<h3 id="移除元素-27"><a href="#移除元素-27" class="headerlink" title="移除元素(27)"></a>移除元素(27)</h3><p>给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。<br>原题链接：<a href="https://leetcode-cn.com/problems/remove-element" target="_blank" rel="noopener">https://leetcode-cn.com/problems/remove-element</a></p><pre><code>给定 nums = [0,1,2,2,3,0,4,2], val = 2,函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。</code></pre><p>原地删除问题，也就是必须在O(1)额外空间的条件下删除数组中的元素，解决这类问题的固定套路是双指针法。</p><ol><li>设置快指针$j$和慢指针$i$;</li><li><strong>如果</strong>$nums_j = val$, 就递增$j$;</li><li><strong>只要</strong>$nums_j \neq val$, 则$nums_i \leftarrow nums_j$, 同时递增$i$和$j$;<pre><code class="lang-Java">for(int j = 0; j &lt; n; j ++){   if(nums[j] != val){     nums[i] = nums[j];     i ++;   }}return i;</code></pre></li></ol><h3 id="删除排序数组中的重复项-26"><a href="#删除排序数组中的重复项-26" class="headerlink" title="删除排序数组中的重复项(26)"></a>删除排序数组中的重复项(26)</h3><p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。<br>原题链接：<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array</a></p><pre><code>给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。</code></pre><p>依旧是原地删除问题，同样可以采用双指针法解决。</p><ol><li>设置快指针$j$和慢指针$i$;</li><li><strong>如果</strong>$nums_j = nums_i$, 就递增$j$;</li><li><strong>只要</strong>$nums_j \neq nums_i$, 同时递增$i$和$j$, $nums_i \leftarrow nums_j$;<pre><code class="lang-Java">int i = 0;for(int j = 1; j &lt; n; j ++){   if(nums[j] != nums[i]){     i ++;     nums[i] = nums[j];   }}</code></pre></li></ol><h3 id="删除排序数组中的重复项-80"><a href="#删除排序数组中的重复项-80" class="headerlink" title="删除排序数组中的重复项(80)"></a>删除排序数组中的重复项(80)</h3><p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。<br>原题链接：<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii</a></p><pre><code>给定 nums = [0,0,1,1,1,1,2,3,3],函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。你不需要考虑数组中超出新长度后面的元素。</code></pre><p>还是原地删除问题，继续采用双指针法解决。不同的是这次元素最多可以重复两次，可以设置一个标志变量$k$，并初始化$k = 0$，表示数组当前的元素只有一个，一旦出现了第二个，则$k = 1$，之后若再出现第三，第四个跟它相同的元素，$k$也不会再发生变化，直到遇到不同的元素为止，$k$重新清为0.</p><ol><li>设置快指针$j$, 慢指针$i$和标志变量$k$;</li><li><strong>如果</strong>$nums_j = nums_i$, 1) 如果$k = 0$, 递增$i$和$j$, $k \leftarrow 1$, $nums_i \leftarrow nums_j$, 2) 如果$k \neq 0$, 递增$j$;</li><li><strong>只要</strong>$nums_j \neq nums_i$, 递增$i$和$j$, $k \leftarrow 0$, $nums_i \leftarrow nums_j$;</li></ol><p>所以看伪代码会发现，$nums_j = nums_i \wedge k = 0$和$nums_j \neq nums_i$这两种情况的执行部分是基本一致的，可看成同一种情况。</p><pre><code class="lang-Java">int i = 0, k = 0;for(int j = 1; j &lt; nums.length; ++ j) {    if(nums[i] == nums[j]) {        if(k == 0) {            i ++;            nums[i] = nums[j];            k ++;        }    }else {        i ++;        nums[i] = nums[j];        k = 0;    }}return i + 1;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode笔记(一)</title>
      <link href="/2019/09/09/leetcode-note-1/"/>
      <url>/2019/09/09/leetcode-note-1/</url>
      
        <content type="html"><![CDATA[<h3 id="两数之和-1"><a href="#两数之和-1" class="headerlink" title="两数之和(1)"></a>两数之和(1)</h3><pre><code>1. 建立map: nums[i] -&gt; i;2. 判断target - nums[i]是否也在map中3. 如果是就返回(i, j)</code></pre><h3 id="两数相加-2"><a href="#两数相加-2" class="headerlink" title="两数相加(2)"></a>两数相加(2)</h3><pre><code>  5 -&gt; 2 -&gt; 3+ 6 -&gt; 1(-&gt; 0)= 1 -&gt; 4 -&gt; 3Node dh = new Node(), cur = dh;carry = 0;while(p != null || q != null){  x = p != null ? p.val: 0;  y = q != null ? q.val: 0;  sum = x + y + carry;  carry = sum / 10;  cur.next = new Node(sum % 10);  cur = cur.next;  if(p != null) p = p.next;  if(q != null) q = q.next;}if(carry &gt; 0)  cur.next = new Node(carry);return dh.next</code></pre><h3 id="无重复字符的最长子串-3"><a href="#无重复字符的最长子串-3" class="headerlink" title="无重复字符的最长子串(3)"></a>无重复字符的最长子串(3)</h3><pre><code>1. 建立map: s[j] -&gt; j + 1, ans = 0;2. 如果s[j]已经存在于map中，起点i可以直接跳跃到map[s[j]]也就是j + 1处，但要注意map中的旧状态还没有移除，比如abcddb这种，所以i = max(map[s[j]], i);3. 更新最长的长度: ans = max(ans, j - i + 1);</code></pre><h3 id="最长回文子串-5"><a href="#最长回文子串-5" class="headerlink" title="最长回文子串(5)"></a>最长回文子串(5)</h3><p>将给定字符串反转, 找出原始字符串和反转字符串的最长公共子串(需要做一点小判断).<br>如果已知两个字符串为$X$和$Y$, 且它们各自的长度为$m$和$n$, 那么它们的最长公共后缀的定义如下：</p><script type="math/tex; mode=display">L(m, n)=\left\{\begin{aligned}&  0 &&\text{if}\;\; m = 0 \vee n = 0 \\&  L(m - 1, n - 1) + 1 &&\text{if}\;\; X_{m - 1} = Y_{n - 1} \\&  0 &&\text{if}\;\;X_{m - 1} \neq Y_{n - 1} \\\end{aligned}\right.</script><p>利用上述公式，采用自底向上的动态规划法，保存子串对的最长公共后缀，再从这些后缀中找出最长的那个即可<br>搭出公式对应的框架：</p><pre><code>int[][] dp = new int[m + 1][n + 1];for(int i = 0; i &lt;= m; i ++){    for(int j = 0; j &lt;= n; j ++){        if(i == 0 || j == 0)          dp[i][j] = 0;        else if(X[i - 1] == Y[j - 1]) //对应回原来的数组的索引时i, j分别要减1          dp[i][j] = dp[i - 1][j - 1] + 1;        else          dp[i][j] = 0;    }}</code></pre><pre><code>但是我们要考虑一个问题, 比如给定字符串dabcbe, 反转后为ebcbad,它们的公共子串为：d a b c b ...    2 3 4-&gt;(i - 1)e b c b ...  1 2 3-&gt;(j - 1)假设字符串长度为n(= 6)，满足n - 1 - (j - 1) + dp[i][j] - 1 = 6 - 1 - 3 + 3 - 1 = 4 == (i - 1)但是如果是abcdecba，反转后为abcedcba, 它们的公共子串为：a b c ...0 1 2a b c ...0 1 2不满足n - 1 - (j - 1) + dp[i][j] - 1 == i - 1</code></pre><p>所以在原来的代码的基础上要加入一些判断:</p><pre><code>int maxlen = 0, maxEnd = 0;for(int i = 0; i &lt;= n; i ++){    for(int j = 0; j &lt;= n; j ++) {        if(i == 0 || j == 0)            dp[i][j] = 0;        else if(s.charAt(i - 1) == rs.charAt(j - 1))            dp[i][j] = dp[i - 1][j - 1] + 1;        else            dp[i][j] = 0;        if(dp[i][j] &gt; maxlen) {            int beforeIndex = n - 1 - (j - 1);            if(beforeIndex + dp[i][j] - 1 == i - 1) {                maxlen = dp[i][j];                maxEnd = i - 1;            }        }    }}返回的公共子串的起点根据maxlen = maxEnd - start + 1得到start = maxEnd - maxlen + 1所以返回substring(maxEnd - maxlen + 1, maxEnd + 1)</code></pre>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客平台搭建</title>
      <link href="/2019/09/03/platform-building/"/>
      <url>/2019/09/03/platform-building/</url>
      
        <content type="html"><![CDATA[<h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>最近博客平台的搭建也告一段落了，再次感谢各位开源大佬，没有你们的支持，我这个小破站也搭建不起来(╯▔皿▔)╯。废话不多说，整个小博客网站主要是借助<a href="https://hexo.io/" target="_blank" rel="noopener">hexo</a>博客框架和<a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank" rel="noopener">3-hexo</a>这个博客主题完成的，3-hexo主题的使用demo可以查看本站下方的友链部分。整个搭建过程真的踩了不少坑，下面我也会分模块尽可能一一讲述清楚。</p><h2 id="hexo搭建步骤"><a href="#hexo搭建步骤" class="headerlink" title="hexo搭建步骤"></a>hexo搭建步骤</h2><h3 id="必要条件"><a href="#必要条件" class="headerlink" title="必要条件"></a>必要条件</h3><ol><li>戳<a href="https://nodejs.org/en/" target="_blank" rel="noopener">nodejs</a>，下载nodejs并安装（本人是在windows上面搭建的），nodejs主要使用npm命令来安装hexo框架的各种插件；</li><li>戳<a href="https://gitforwindows.org/" target="_blank" rel="noopener">git</a>安装windows版git，主要目的是让hexo和github pages配合更新。</li></ol><h3 id="hexo安装"><a href="#hexo安装" class="headerlink" title="hexo安装"></a>hexo安装</h3><p>使用git-bash或者cmd即可安装hexo</p><pre><code>$ npm install -g hexo-cli</code></pre><h3 id="网站配置"><a href="#网站配置" class="headerlink" title="网站配置"></a>网站配置</h3><p>在你指定的存放网站文件的目录下（我的是brightblog，这个目录在后文将被称为hexo根目录）执行下面三行命令：</p><pre><code>$ hexo init brightblog$ cd brightblog$ npm install</code></pre><p>新建完成后可以看到目录下的结构为：</p><pre><code>.├── _config.yml├── package.json├── scaffolds├── source|   ├── _drafts|   └── _posts└── themes</code></pre><p>各个目录的主要功能如下所示：</p><div class="table-container"><table><thead><tr><th>文件/目录</th><th>功能</th></tr></thead><tbody><tr><td>_config.xml</td><td>网站的<a href="https://hexo.io/zh-cn/docs/configuration.html" target="_blank" rel="noopener">配置</a>文件</td></tr><tr><td>package.json</td><td>应用程序的信息</td></tr><tr><td>scaffolds</td><td><a href="https://hexo.io/zh-cn/docs/templates.html" target="_blank" rel="noopener">模版</a>文件夹。当您新建文章时，Hexo 会根据scaffold来建立文件</td></tr><tr><td>source</td><td><a href="https://hexo.io/zh-cn/docs/asset-folders.html" target="_blank" rel="noopener">资源文件夹</a>是存放用户资源的地方。除 posts 文件夹之外，开头命名为 (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去</td></tr><tr><td>themes</td><td><a href="https://hexo.io/zh-cn/docs/themes.html" target="_blank" rel="noopener">主题</a>文件夹，Hexo 会根据主题来生成静态页面</td></tr></tbody></table></div><p><br><br>个人认为比较重要的几个文件_config.yml，source目录和themes目录，它们分别是你配置网站，存在博客和存放主题的地方。关于_config.yml，我配置的几个主要地方是：</p><pre><code># 网站标题title: Zeroone# 作者名字author: J. Zhang# 站点的urlurl: https://blog.jtzhang.xyz# 使用的主题，所有的主题都按照名称存放在themes目录下，可根据需要切换theme: hexo-theme-3-hexo# 开启全文搜索(in:)search:  path: search.xml  field: post# 站点部署配置deploy:  - type: git    repo: git@github.com:brightLLer/brightLLer.github.io.git    branch: master</code></pre><h3 id="下载和配置主题"><a href="#下载和配置主题" class="headerlink" title="下载和配置主题"></a>下载和配置主题</h3><p>切换到hexo根目录下的themes文件夹，并执行如下命令下载主题（我使用的是3-hexo主题）：</p><pre><code>$ cd themes/$ git init$ git clone https://github.com/yelog/hexo-theme-3-hexo.git</code></pre><p>下载好的主题的名字要配置在hexo根目录下的_config.yml文件中（见上一小节）。一般来说，一个主题的目录具有如下的文件结构：</p><pre><code>.├── _config.yml├── languages├── layout├── scripts└── source</code></pre><p>主题目录下各个文件/目录的主要功能如下所示:</p><div class="table-container"><table><thead><tr><th>文件/目录</th><th>功能</th></tr></thead><tbody><tr><td>_config.yml</td><td>主题的配置文件</td></tr><tr><td>languages</td><td>语言文件夹，请参见<a href="https://hexo.io/zh-cn/docs/internationalization.html" target="_blank" rel="noopener">国际化 (i18n)</a></td></tr></tbody></table></div><p>layout|布局文件夹。用于存放主题的<a href="https://hexo.io/zh-cn/docs/templates.html" target="_blank" rel="noopener">模板</a>文件，决定了网站内容的呈现方式，您可参考模板以获得更多信息|<br>|scripts|脚本文件夹。在启动时，Hexo 会载入此文件夹内的 JavaScript 文件，参见<a href="https://hexo.io/zh-cn/docs/plugins.html" target="_blank" rel="noopener">插件</a>获取更多信息|<br>|source|资源文件夹，除了模板以外的 Asset，例如 CSS、JavaScript 文件等，都应该放在这个文件夹中。文件或文件夹开头名称为 _（下划线线）或隐藏的文件会被忽略|</p><p><br><br>这里值得一提的是_config.yml文件，这个文件与hexo根目录下的_config.yml文件是不一样的，前者主要用于主题相关的配置，后者则主要是进行网站本身的全局配置。关于主题目录下的_config.yml，我配置的几个主要地方是：</p><pre><code># 你的头像urlavatar: /img/zeroone.pngfavicon: /img/zeroone.png#链接图标 显示顺序和下面顺序一致link:  theme: color # 链接样式，color: 彩色图标  white: 黑白图标  items:    # rss: /atom.xml    github: https://github.com/brightLLer    zhihu: https://www.zhihu.com/people/brightspring/activities    email: 1277472231@qq.com    qq: 1277472231menu:  about:  # &#39;关于&#39; 按钮    on: true # 是否显示    url: /about  # 跳转链接    type: 1 # 跳转类型 1：站内异步跳转 2：当前页面跳转 3：打开新的tab页  friend: # &#39;友链&#39; 按钮    on: true # 是否展示  menus:    github:      on: true      url: https://github.com/brightller      type: 3  # 跳转类型 3：打开新的tab页article_txt: 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论，也可以邮件至 1277472231@qq.combottom_text: ©2019 Jiantao Zhangreward: true# true 开启打赏功能searchAll: true# true 启用全文搜索# 开启此功能需要下面操作：# 1. 在 hexo 根目录 执行 npm install hexo-generator-search --save 安装插件# 2. 在 hexo 根目录的 _config.xml 中添加下面内容# search:#   path: search.xml#   field: postword_count: true# true 开启字数统计# 开启此功能需要安装插件 ：在 hexo根目录 执行npm i hexo-wordcount --savecomment:  on: true  type: gitalk  # 评论系统：gitalk、disqus、gentie、gitment,注意：使用时，在下方对应位置进行配置  comment_count: true  # 文章标题下方显示评论数  preload_comment: false  # 预加载评论区  ## false: 当点击评论条等区域时再加载评论模块  ## true: 页面加载时加载评论区gitalk:  githubID: brightller  repo: brightller.github.io  ClientID:  ClientSecret:  adminUser: brightller  distractionFreeMode: true  language: zh-CN  perPage: 10# gitalk：利用github issue制作的第三方聊天插件# https://github.com/gitalk/gitalk# 参数介绍：# githubID: github用户名# repo: 使用哪个仓库的issue# ClientID 和 ClientSecret 创建 OAuth application 就会生成：https://github.com/settings/applications/new# adminUser: 必须为上面仓库的合作者（有写入权限），使用自己的 github 用户名即可# distractionFreeMode: 全屏遮罩效果# language: 语言：支持：en / zh-CN / zh-TW 三种# perPage: 每次加载的数据大小，默认10，最大100</code></pre><h2 id="站点测试和部署"><a href="#站点测试和部署" class="headerlink" title="站点测试和部署"></a>站点测试和部署</h2><p>在hexo根目录/站点根目录(brightblog)下打开cmd命令行，执行如下命令</p><pre><code>hexo s</code></pre><p>之后再浏览器的地址栏输入<code>http://localhost:4000</code>就可以看到测试的站点，如下图所示，按住<code>Ctrl+C</code>可以退出本地测试。<br><img src="/img/local-test.png"><br>如果检查后觉得测试页面没有什么问题，就可以部署到Github pages上面了。</p><ol><li>首先在git-bash上执行如下命令安装部署hexo站点用的插件：<pre><code>npm install hexo-deployer-git --save</code></pre></li><li>在Github上创建名为<code>&lt;username&gt;.github.io</code>的仓库，比如我的就是<code>brightller.github.io</code></li><li>在网站的配置文件（不是主题的配置文件）_config.yml中填好部署的配置：<pre><code>deploy:- type: git repo: git@github.com:brightLLer/brightLLer.github.io.git branch: master</code></pre></li><li><p>一般来说,github提交代码有两种方式，一种为HTTPS方式，另一种为SSH方式：</p><pre><code># HTTPS方式:https://github.com/brightLLer/brightLLer.github.io.git# SSH方式:git@git.com:brightLLer/brightLLer.github.io.git</code></pre><p>以HTTPS方式提交代码需要每次手动输入github的账号密码，而SSH方式是将本地系统的公钥(每换一台电脑就要重新生成一次)提供给github，之后就不需要每次手动输入账号和密码了，回头看第3点，由于部署的方式是SSH方式，因此我们需要先生成SSH密钥：</p><pre><code>ssh-keygen -t rsa -C &quot;1277472231@qq.com&quot;</code></pre><p>接着切换到<code>C:\Users\&lt;local_user&gt;\.ssh</code>下，可以看到目录结构：</p><pre><code>.├── id_rsa├── id_rsa.pub└── known_hosts</code></pre><p>将id_rsa.pub中的公钥复制到github上面：</p><pre><code>头像 -&gt; settings -&gt; SSH and GPG keys -&gt; New SSH key -&gt; 填写title(随意)和key</code></pre><p><img src="/img/SSH-github.png"></p></li><li><p>关联本地仓库和远程仓库:</p><pre><code>git remote add origin git@git.com:brightLLer/brightLLer.github.io.git# 或者git remote add origin https://github.com/brightLLer/brightLLer.github.io.git# 可缺省https链接</code></pre></li><li><p>最终部署：</p><pre><code># 第一次部署hexo deploy# 非第一次部署（修改过内容后重新部署，如主题）hexo cleanhexo generatehexo deploy</code></pre></li></ol><p>除此之外，为了开启评论系统Gitalk，我们需要注册<a href="https://github.com/settings/applications/new" target="_blank" rel="noopener">OAuth Application</a>，进去之后我们可以看到下方的界面：<br><img src="/img/OAuth-App.png"><br>这里<code>https://blog.jtzhang.xyz/</code>是我申请的域名，如果没有域名就还是填原来的<code>https://&lt;username&gt;.github.io/</code>就可以了，注册好之后我们会得到自己的<code>client_id</code>和<code>client_secret</code>，可以在github中采用如下方式进入查看：</p><pre><code>头像 -&gt; Developer settings -&gt; OAuth Apps -&gt; App头像</code></pre><p>将它们填写到主题配置文件_config.yml（注意不是网站配置文件_config.yml）上对应的位置就可以了：</p><pre><code>gitalk:  githubID: brightller  repo: brightller.github.io  ClientID: your client_id  ClientSecret: your client_secret  adminUser: brightller  distractionFreeMode: true  language: zh-CN  perPage: 10</code></pre><h2 id="申请自己的域名"><a href="#申请自己的域名" class="headerlink" title="申请自己的域名"></a>申请自己的域名</h2><p>由于我使用的是腾讯云，所以将腾讯云作为例子，其它平台的操作也是类似的。</p><ol><li>注册腾讯云账号，登录，进入控制台，购买域名，域名大部分需要实名认证，上传自己的身份证即可，审核一般当天能完成.</li><li>进入域名管理，如果审核通过了，可以看到：<br><img src="/img/domain-manage.png"></li><li>点击上图中的解析，进入之后点击添加如下3条记录，其中前两条是固定的，解析的是github的IP地址，最后一条请填写你自己的仓库名<code>&lt;username&gt;.github.io</code>，主机记录可以随意填，既然是博客可以采用blog这样的一个二级域名，记录类型建议填写CNAME，不要填A，这样github仓库待24小时内审核之后可以直接勾上enfore https，这样网站就可以安全访问了：<br><img src="/img/all-records.png"><br><img src="/img/enforce-https.png"></li><li>在hexo根目录的source文件夹下建立一个名为CNAME的文件(不需要扩展名)，然后在里面写上申请的域名，比如我的就是blog.jtzhang.xyz</li><li>重新clean，generate，deploy，就可以直接使用域名访问自己的网站了.</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://hexo.io/" target="_blank" rel="noopener">https://hexo.io/</a></p><p><a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank" rel="noopener">https://github.com/yelog/hexo-theme-3-hexo</a></p><p><a href="https://www.yuque.com/skyrin/coding/tm8yf5" target="_blank" rel="noopener">https://www.yuque.com/skyrin/coding/tm8yf5</a></p><p><a href="https://imsun.net/posts/gitment-introduction/" target="_blank" rel="noopener">https://imsun.net/posts/gitment-introduction/</a></p><p><a href="https://www.cnblogs.com/liuurick/p/10713687.html" target="_blank" rel="noopener">https://www.cnblogs.com/liuurick/p/10713687.html</a></p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 3-hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>librosa术语介绍</title>
      <link href="/2019/09/02/librosa-term/"/>
      <url>/2019/09/02/librosa-term/</url>
      
        <content type="html"><![CDATA[<h1 id="librosa中的相关术语介绍"><a href="#librosa中的相关术语介绍" class="headerlink" title="librosa中的相关术语介绍"></a>librosa中的相关术语介绍</h1><blockquote><p>注：librosa是一个音频处理库，戳<a href="http://librosa.github.io/librosa/" target="_blank" rel="noopener">这里</a>看官方document。</p></blockquote><h2 id="术语解释"><a href="#术语解释" class="headerlink" title="术语解释"></a>术语解释</h2><h3 id="time-series"><a href="#time-series" class="headerlink" title="time series"></a><strong>time series</strong></h3><p>Typically an audio signal, denoted by <code>y</code>, and represented as a one-dimensional numpy.ndarray of floating-point values. <code>y[t]</code> corresponds to amplitude of the waveform at sample <code>t</code>.<br>时间序列：一般指的是音频信号，用<code>y</code>来表示，<code>y</code>是一个浮点类型的一维数组，<code>y[t]</code>表示波形图中样本<code>t</code>处的幅度值</p><h3 id="sampling-rate"><a href="#sampling-rate" class="headerlink" title="sampling rate"></a><strong>sampling rate</strong></h3><p>The (positive integer) number of samples per second of a time series. This is denoted by an integer variable <code>sr</code>.<br>采样频率：时间序列中，每秒的样本数目（一个正整数）。经常用一个整型变量<code>sr</code>来表示</p><h3 id="frame"><a href="#frame" class="headerlink" title="frame"></a><strong>frame</strong></h3><p>A short slice of a time series used for analysis purposes. This usually corresponds to a single column of a spectrogram matrix.<br>帧：一个时间序列的短切片，常用于分析。帧通常与时频矩阵中一个单独的列相关（specgram的行表示频率，列表示时间），强调一点，帧的意义是时间上的。</p><h3 id="window"><a href="#window" class="headerlink" title="window"></a><strong>window</strong></h3><p>The (positive integer) number of samples in an analysis window (or frame). This is denoted by an integer variable <code>n_fft</code>.<br>在一个分析窗（或者帧）内的样本的数目（一个正整数）。用整型变量<code>n_fft</code>来表示。<br>注：1、傅里叶变换只能对作用于有限长度的信号，因此才要对信号采样，采样数目<code>n_fft</code>就是一帧的长度<br>2、帧的中心样本称为center，<code>stft</code>等函数中，<code>center</code>参数若为<code>True</code>，信号y会被左右填充(padded)以确保第<code>k</code>帧以<code>k*hop_length</code>那个样本为中心（v3.0开始），若为<code>False</code>，则不填充而且第k帧的起点就是<code>k*hop_length</code>那个样本。对应到specgram中就是<code>D[:, t]</code>或者<code>S[:, t]</code><br>center : boolean</p><ul><li>If <code>True</code>, the signal <code>y</code> is padded so that frame <code>D[:, t]</code> is centered at <code>y[t * hop_length]</code>.</li><li>If <code>False</code>, then <code>D[:, t]</code> begins at <code>y[t * hop_length]</code><h3 id="hop-length"><a href="#hop-length" class="headerlink" title="hop length"></a><strong>hop length</strong></h3>The number of samples between successive frames, e.g., the columns of a spectrogram. This is denoted as a positive integer <code>hop_length</code>.<br>帧移：连续帧之间的样本数目，用一个正整数变量<code>hop_length</code>来表示。注：其实就是上一帧的起点到下一帧起点的位移<h3 id="window-length"><a href="#window-length" class="headerlink" title="window length"></a><strong>window length</strong></h3>The length (width) of the window function (e.g., Hann window). Note that this can be smaller than the frame length used in a short-time Fourier transform. Typically denoted as a positive integer variable <code>win_length</code>.<br>窗长度：窗的长度（宽度），在短时傅里叶变换中可以比帧长度小（多数时候两者长度一样，窗长小于帧长时使用零填充补充至长度相等）。经常用正整数变量<code>win_length</code>来表示<h3 id="spectrogram"><a href="#spectrogram" class="headerlink" title="spectrogram"></a><strong>spectrogram</strong></h3>A matrix <code>S</code> where the rows index frequency bins, and the columns index frames (time). Spectrograms can be either real-valued or complex-valued. By convention, real-valued spectrograms are denoted as numpy.ndarrays <code>S</code>, while complex-valued STFT matrices are denoted as <code>D</code>.<br>时频矩阵：一个矩阵，其行索引频带，列索引帧（时间）。时频矩阵的元素可以是实数也可以是复数。按照约定俗成的表示，实数时频矩阵用数组<code>S</code>表示，而复数STFT矩阵则用<code>D</code>表示<br><code>np.abs(D[f, t])</code> is the magnitude of frequency bin <code>f</code> at frame <code>t</code><br><code>np.angle(D[f, t])</code> is the phase of frequency bin <code>f</code> at frame <code>t</code><h3 id="onset-strength-envelope"><a href="#onset-strength-envelope" class="headerlink" title="onset (strength) envelope"></a><strong>onset (strength) envelope</strong></h3>An onset envelope <code>onset_env[t]</code> measures the strength of note onsets at frame <code>t</code>. Typically stored as a one-dimensional numpy.ndarray of floating-point values onset_envelope.<br>帧起点数组：记录着每一帧起始时刻处的强度，用一个浮点型一维数组<code>onset_envelope</code>来表示</li></ul>]]></content>
      
      
      <categories>
          
          <category> 语音分离 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> librosa </tag>
            
            <tag> signal processing </tag>
            
            <tag> speech separation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>librosa补充(一)</title>
      <link href="/2019/09/02/librosa-additional/"/>
      <url>/2019/09/02/librosa-additional/</url>
      
        <content type="html"><![CDATA[<h1 id="补充几个概念以及对部分API的理解"><a href="#补充几个概念以及对部分API的理解" class="headerlink" title="补充几个概念以及对部分API的理解"></a>补充几个概念以及对部分API的理解</h1><blockquote><p>注：时域信号在经过傅里叶变换转换之后一般为复数形式</p></blockquote><h2 id="amplitude和magnitude的区别"><a href="#amplitude和magnitude的区别" class="headerlink" title="amplitude和magnitude的区别"></a><strong>amplitude和magnitude的区别</strong></h2><ul><li>peak amplitude, often shortened to amplitude, is the nonnegative value of the waveform’s peak (either positive or negative).(强调信号的峰值)</li><li>instantaneous amplitude of x is the value of x(t) (either positive or negative) at time t.（瞬时幅度，信号x(t)在t处的值）</li><li>instantaneous magnitude, or simply magnitude, of x is nonnegative and is given by |x(t)|.（瞬时幅度，信号x(t)的模）<br>需要特意强调的就是，magnitude指的是模，不过在多数情况下，amplitude和magnitude在fft中一般是同一个意思。</li></ul><h2 id="振幅，分贝-dB-和能量-power-之间的转换关系"><a href="#振幅，分贝-dB-和能量-power-之间的转换关系" class="headerlink" title="振幅，分贝(dB)和能量(power)之间的转换关系"></a><strong>振幅，分贝(dB)和能量(power)之间的转换关系</strong></h2><ul><li>振幅：由于傅里叶变换之后得到的为复数T-F矩阵D，在python里，可以简单得到振幅的T-F矩阵和相位(幅角)的T-F矩阵：<pre><code>S = np.abs(D)P = np.angle(D)</code></pre></li><li><p>分贝：librosa的官方文档中对分贝的计算公式定义如下：</p><pre><code>S_db = 20 * np.log10(S / ref)</code></pre><p>其中ref的默认取值为1.0，不过文档似乎更习惯于用<code>ref = np.max(S)</code></p></li><li><p>能量：T-F矩阵中每个T-F单元的能量就是幅值取平方即可</p><pre><code>S_power = S ** 2</code></pre><h2 id="librosa中xx-to-xx型的API"><a href="#librosa中xx-to-xx型的API" class="headerlink" title="librosa中xx_to_xx型的API"></a><strong>librosa中xx_to_xx型的API</strong></h2></li><li><p><code>amplitude_to_db(S[, ref, amin, top_db])</code><br>该API是将幅值转换为分贝，这里的第一个参数S，按照librosa相关术语的描述，应该是一个实数T-F矩阵而不是复数T-F矩阵，但实际测试的时候发现API传入S和D的效果是一样的，源码内部实际上有一句<code>magnitude = np.abs(S)</code>，那么说明参数中的S实际上是被当成D来看的，D中的每个瞬时值被称为amplitude，不过从字面意义上来看，还是当成实数T-F矩阵S来看比较好，也就是说时域信号<code>y</code>经过STFT变换后得到<code>D</code>，先经过<code>S = np.abs(D)</code>之后再传入该API中的S，当然直接传入<code>D</code>也没有任何问题。此外该<code>amplitude_to_db(S)</code>与<code>power_to_db(S ** 2)</code>等价。</p></li><li><p><code>db_to_amplitude(S_db[, ref])</code><br>将分贝转换为幅值。这里的幅值是实数，用magnitude更合适，强调模S。</p></li><li><p><code>power_to_db(S[, ref, amin, top_db, ref_power])</code><br>能量转换为分贝，ref_power参数会在0.6.0版本起抛弃。</p></li><li><p><code>db_to_power(S_db[, ref])</code><br>分贝转换为能量。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 语音分离 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> librosa </tag>
            
            <tag> signal processing </tag>
            
            <tag> speech separation </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
